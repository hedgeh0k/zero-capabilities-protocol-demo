/**
 * Browser page for User C.
 *
 * This simple server renders a list of the four scenarios defined
 * in the assignment.  When a user clicks a scenario the server
 * reads the corresponding capability JSON from the shared volume,
 * issues an HTTP request to the appropriate dataset server and
 * returns the raw response to the browser.  All signing occurs
 * serverâ€‘side: the UI never exposes the private key to the browser.
 */

import http from 'node:http';
import fs from 'node:fs/promises';
import {URL} from 'node:url';
// Suppress type checking for imports from compiled common modules.
// @ts-ignore
import {log} from '../../common/dist/logger.js';
// @ts-ignore
import escapeHtml from 'escape-html';

// Determine which actor this UI represents.  The docker build can
// provide CLIENT_LABEL as a build argument.  It defaults to UserC.
const CLIENT: string = process.env.CLIENT_LABEL || 'UserC';
const DATA_PORT = Number(process.env.DATA_PORT) || 3000;

// Load all key material once at startup.  Keys are stored in the
// shared /caps directory generated by the issuer.  We parse the
// file into an object mapping actor labels to their keys and DIDs.
async function loadKeys() {
    const capsDir = process.env.CAPS_DIR || '/caps';
    const raw = await fs.readFile(`${capsDir}/keys.json`, 'utf8');
    return JSON.parse(raw);
}

// The list of scenario identifiers to display in the UI.  These must
// match the filenames written by the issuer.
const LIST = ['abc-A', 'abc-B', 'abc-C', 'abc-D'] as const;
// Human readable descriptions for the scenarios.
const DESCRIPTIONS: Record<typeof LIST[number], string> = {
    'abc-A':
        'Company A keeps dataset "AB" for Company B; C should be denied.',
    'abc-B':
        'Dataset "AC" is delegated by A to B and further to C for reading.',
    'abc-C':
        'A lets B transform "AB" via x-to-y; only A and B may read the result.',
    'abc-D':
        'A lets B transform "AB" via x-to-z and delegate the result to C.',
};
// Expected HTTP status codes for each scenario.
const EXPECTED: Record<typeof LIST[number], number> = {
    'abc-A': 403,
    'abc-B': 200,
    'abc-C': 403,
    'abc-D': 200,
};

const ACTIONS: Record<typeof LIST[number], string> = {
    'abc-A': 'C tries to read dataset AB',
    'abc-B': 'C reads dataset AC via delegation',
    'abc-C': 'C requests x-to-y transform of AB',
    'abc-D': 'C reads x-to-z transform of AB',
};

async function main() {
    const keys = await loadKeys();
    const clientDid = keys[CLIENT].did;

    const server = http.createServer(async (req, res) => {
        try {
            if (!req.url) {
                res.statusCode = 400;
                res.end('bad request');
                return;
            }
            const url = new URL(req.url, 'http://localhost');
            if (url.pathname === '/') {
                // Render a dashboard table for each scenario.
                const rows = LIST.map(
                    (id) =>
                        `<tr><td>${id}</td><td>${DESCRIPTIONS[id]}</td><td>${EXPECTED[id]}</td><td><a href="/run/${id}">${ACTIONS[id]}</a></td></tr>`
                ).join('');
                const scenarioItems = LIST.map(
                    (id) => `<li>${id}: ${DESCRIPTIONS[id]}</li>`
                ).join('');
                res.setHeader('content-type', 'text/html; charset=utf-8');
                res.end(
                    `<h1>ABC Demo (Client = ${CLIENT})</h1>` +
                        `<details open><summary>What you're looking at</summary>` +
                        `<p>This demo starts an issuer, dataset servers for Company A and Company B, and this UI acting as User C.</p>` +
                        `<p>The issuer generated demo keys and four capabilities. Select a scenario to watch a capability travel from the issuer to a dataset server and back.</p>` +
                        `<ol>` +
                        `<li>The issuer writes keys and capabilities to a shared <code>/caps</code> folder.</li>` +
                        `<li>Dataset servers verify the capability when requests arrive.</li>` +
                        `<li>This UI invokes a scenario as User C to fetch or transform data.</li>` +
                        `</ol>` +
                        `<p>Scenarios:</p><ul>${scenarioItems}</ul>` +
                        `<details><summary>Demo keys (do not reuse)</summary><pre>${escapeHtml(
                            JSON.stringify(keys, null, 2)
                        )}</pre></details>` +
                        `</details>` +
                        `<table><thead><tr><th>ID</th><th>Description</th><th>Expected HTTP</th><th>Action</th></tr></thead>` +
                        `<tbody>${rows}</tbody></table>`
                );
                return;
            }
            if (url.pathname.startsWith('/run/')) {
                const id = url.pathname.slice('/run/'.length) as typeof LIST[number];
                if (!LIST.includes(id)) {
                    res.statusCode = 404;
                    res.end('unknown scenario');
                    return;
                }
                // Read capability JSON from the shared volume.
                const capDir = process.env.CAPS_DIR || '/caps';
                const capPath = `${capDir}/${id}.json`;
                const capJSON = await fs.readFile(capPath, 'utf8');
                const cap = JSON.parse(capJSON);
                // Determine the target dataset server and request path based on
                // the capability.
                let path: string;
                let domain: string;
                try {
                    if (cap.allowedActions.includes('transform')) {
                        if (!cap.caveats?.protocol || !cap.caveats?.targetDomain) {
                            throw new Error('missing transform caveats');
                        }
                        path = `/${cap.caveats.protocol}.json`;
                        domain = cap.caveats.targetDomain;
                    } else {
                        const t = new URL(cap.invocationTarget);
                        path = t.pathname;
                        domain = t.hostname;
                        if (!domain) {
                            throw new Error('missing domain');
                        }
                    }
                } catch (e: any) {
                    const msg = `invalid capability target: ${e.message || e}`;
                    log('ðŸ”´', `${id} â†’ ${msg}`, e);
                    res.statusCode = 500;
                    res.end(msg);
                    return;
                }

                const urlToFetch = `http://${domain}:${DATA_PORT}${path}`;
                log('ðŸ“¡', `${id} â†’ ${urlToFetch}`);
                // Perform the HTTP request to the dataset server.  We attach
                // the capability id and the caller DID in headers.  The
                // request method is always GET.  If fetch throws an error we
                // catch it and report the error to the client.
                const requestHeaders = {
                    'capability-id': cap.id,
                    'caller-did': clientDid,
                };
                let status: number;
                let text: string;
                let responseHeaders: Record<string, string> = {};
                try {
                    const response = await fetch(urlToFetch, {
                        method: 'GET',
                        headers: requestHeaders,
                    });
                    status = response.status;
                    responseHeaders = Object.fromEntries(response.headers);
                    text = await response.text();
                    log(response.ok ? 'ðŸŸ¢' : 'ðŸ”´', `${id} â†’ ${response.status}`);
                } catch (e: any) {
                    status = 500;
                    text = String(e.message || e);
                    log('ðŸ”´', `${id} â†’ error: ${text}`, e);
                }
                // Render the result page.  All user supplied data is escaped.
                res.setHeader('content-type', 'text/html; charset=utf-8');
                res.end(
                    `<h2>${id}</h2>\n` +
                        `<p>${DESCRIPTIONS[id]}</p>\n` +
                        `<p>${escapeHtml(urlToFetch)}</p>\n` +
                        `<details open><summary>Capability JSON</summary><pre>${escapeHtml(
                            JSON.stringify(cap, null, 2)
                        )}</pre></details>\n` +
                        `<details><summary>Request headers</summary><pre>${escapeHtml(
                            JSON.stringify(requestHeaders, null, 2)
                        )}</pre></details>\n` +
                        `<h3>HTTP ${status}</h3>\n` +
                        `<details><summary>Response headers</summary><pre>${escapeHtml(
                            JSON.stringify(responseHeaders, null, 2)
                        )}</pre></details>\n` +
                        `<pre>${escapeHtml(text)}</pre>`
                );
                return;
            }
            // Unknown route.
            res.statusCode = 404;
            res.end('not found');
        } catch (err: any) {
            console.error(err);
            res.statusCode = 500;
            res.end('internal error');
        }
    });
    server.listen(8080, () => log('ðŸŒ', `UI ready (http://localhost:4500)`));
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
