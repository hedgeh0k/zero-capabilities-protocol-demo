/** --------------------------------------------------------------
 * Browser page for User C.
 *
 * This simple server renders a list of the four scenarios defined
 * in the assignment.  When a user clicks a scenario the server
 * reads the corresponding capability JSON from the shared volume,
 * issues an HTTP request to the appropriate dataset server and
 * returns the raw response to the browser.  All signing occurs
 * serverâ€‘side: the UI never exposes the private key to the browser.
 *
 * NOTE: The builtâ€‘in Node fetch API is used to perform HTTP
 * requests.  No third party dependencies are required.
 * -------------------------------------------------------------- */

import http from 'node:http';
import fs from 'node:fs/promises';
import {URL} from 'node:url';
// Suppress type checking for imports from compiled common modules.
// @ts-ignore
import {log} from '../../common/dist/logger.js';

// Determine which actor this UI represents.  The docker build can
// provide CLIENT_LABEL as a build argument.  It defaults to UserC.
const CLIENT: string = process.env.CLIENT_LABEL || 'UserC';

// Load all key material once at startup.  Keys are stored in the
// shared /caps directory generated by the issuer.  We parse the
// file into an object mapping actor labels to their keys and DIDs.
async function loadKeys() {
    const capsDir = process.env.CAPS_DIR || '/caps';
    const raw = await fs.readFile(`${capsDir}/keys.json`, 'utf8');
    return JSON.parse(raw);
}

// The list of scenario identifiers to display in the UI.  These must
// match the filenames written by the issuer.
const LIST = ['abc-A', 'abc-B', 'abc-C', 'abc-D'] as const;
// Human readable descriptions for the scenarios.
const DESCRIPTIONS: Record<typeof LIST[number], string> = {
    'abc-A': 'A owns dataset X and lets B read it. (C should fail)',
    'abc-B': 'A â†’ B (read + delegate) â†’ C may read dataset X.',
    'abc-C': 'A allows B to transform X via x-to-y; only A and B may read.',
    'abc-D': 'A allows B to transform X via x-to-z; only C may read.',
};

async function main() {
    const keys = await loadKeys();
    const clientDid = keys[CLIENT].did;
    // Precompute mapping from example domains to local ports.  In a real
    // deployment a reverse proxy would route by hostname, but for this
    // demo we hard code the host ports from docker-compose.yml.
    const domainToPort: Record<string, number> = {
        'a.example.com': 4100,
        'b.example.com': 4200,
    };

    const server = http.createServer(async (req, res) => {
        try {
            if (!req.url) {
                res.statusCode = 400;
                res.end('bad request');
                return;
            }
            const url = new URL(req.url, 'http://localhost');
            if (url.pathname === '/') {
                // Render a simple HTML page listing each scenario.  Links
                // navigate back to the same server using /run/<scenario>.
                const listHtml = LIST.map((id) => `<li><a href="/run/${id}">${id}</a></li>`).join('');
                res.setHeader('content-type', 'text/html; charset=utf-8');
                res.end(`<h1>ABC Demo (Client = ${CLIENT})</h1>
<ol>${listHtml}</ol>
<p>Click a scenario â€“ you will see the capability JSON, the
HTTP status from server A/B, and the raw dataset or an error message.</p>`);
                return;
            }
            if (url.pathname.startsWith('/run/')) {
                const id = url.pathname.slice('/run/'.length) as typeof LIST[number];
                if (!LIST.includes(id)) {
                    res.statusCode = 404;
                    res.end('unknown scenario');
                    return;
                }
                // Read capability JSON from the shared volume.
                const capDir = process.env.CAPS_DIR || '/caps';
                const capPath = `${capDir}/${id}.json`;
                const capJSON = await fs.readFile(capPath, 'utf8');
                const cap = JSON.parse(capJSON);
                // Determine the target dataset server and request path based on
                // the capability.  For read capabilities we use the path of
                // invocationTarget.  For transform capabilities we use the
                // protocol specified in the caveats and append .json.
                let targetPath: string;
                let targetDomain: string;
                if (cap.allowedActions.includes('transform')) {
                    // For transforms we trust the protocol + targetDomain caveat.
                    const proto = cap.caveats?.protocol;
                    targetPath = `/${proto}.json`;
                    targetDomain = cap.caveats?.targetDomain ?? 'b.example.com';
                } else {
                    // Plain read â†’ derive from invocationTarget.
                    try {
                        const t = new URL(cap.invocationTarget);
                        targetPath = t.pathname;
                        targetDomain = t.hostname;
                    } catch {
                        targetPath = '/';
                        targetDomain = 'a.example.com';
                    }
                }

                const host = `http://${targetDomain}:3000`;
                const urlToFetch = `${host}${targetPath}`;
                log('ðŸ“¡', `${id} â†’ ${urlToFetch}`);
                // Perform the HTTP request to the dataset server.  We attach
                // the capability id and the caller DID in headers.  The
                // request method is always GET.  If fetch throws an error we
                // catch it and report the error to the client.
                let status: number;
                let text: string;
                try {
                    const response = await fetch(urlToFetch, {
                        method: 'GET',
                        headers: {
                            'Capability-Id': cap.id,
                            'Caller-Did': clientDid,
                        },
                    });
                    status = response.status;
                    text = await response.text();
                    log(response.ok ? 'ðŸŸ¢' : 'ðŸ”´', `${id} â†’ ${response.status}`);
                } catch (e: any) {
                    status = 500;
                    text = String(e.message || e);
                    log('ðŸ”´', `${id} â†’ error: ${text}`, e);
                }
                // Render the result page.  We escape the capability JSON and
                // result to prevent injection issues.  Because this is a
                // demonstration no templating library is used.
                const escapeHtml = (s: string) => s.replace(/[&<>]/g, (c) => {
                    switch (c) {
                        case '&':
                            return '&amp;';
                        case '<':
                            return '&lt;';
                        case '>':
                            return '&gt;';
                        default:
                            return c;
                    }
                });
                res.setHeader('content-type', 'text/html; charset=utf-8');
                res.end(
                    `<h2>${id}</h2>\n` +
                    `<p>${DESCRIPTIONS[id]}</p>\n` +
                    `<p><strong>Request:</strong> ${escapeHtml(urlToFetch)}</p>\n` +
                    `<pre>${escapeHtml(capJSON)}</pre>\n` +
                    `<h3>HTTP ${status}</h3>\n` +
                    `<pre>${escapeHtml(text)}</pre>`
                );
                return;
            }
            // Unknown route.
            res.statusCode = 404;
            res.end('not found');
        } catch (err: any) {
            console.error(err);
            res.statusCode = 500;
            res.end('internal error');
        }
    });
    server.listen(8080, () => log('ðŸŒ', `UI ready (http://localhost:4500)`));
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
